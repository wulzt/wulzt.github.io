<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="跨域一、什么是跨域浏览器的同源策略 1. 什么是同源策略及其限制内容同源策略是一种约定，它是浏览器最核心也是最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSRF等攻击。所谓同源是指”协议+域名+端口”三者相同，即便两个不同的域名指向同一个ip地址，也非同源。  同源策略限制内容有：  Cookie、LocalStorage、IndexedDB等存储性内容 DOM节点 AJAX请求">
<meta property="og:type" content="article">
<meta property="og:title" content="跨域">
<meta property="og:url" content="http://yoursite.com/2019/09/24/跨域/index.html">
<meta property="og:site_name" content="kowukowuko">
<meta property="og:description" content="跨域一、什么是跨域浏览器的同源策略 1. 什么是同源策略及其限制内容同源策略是一种约定，它是浏览器最核心也是最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSRF等攻击。所谓同源是指”协议+域名+端口”三者相同，即便两个不同的域名指向同一个ip地址，也非同源。  同源策略限制内容有：  Cookie、LocalStorage、IndexedDB等存储性内容 DOM节点 AJAX请求">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/2019/09/24/跨域/1638b3579d9eeb32.png">
<meta property="og:image" content="http://yoursite.com/2019/09/24/跨域/1638b3579dde630e.png">
<meta property="og:updated_time" content="2019-11-26T11:24:42.542Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="跨域">
<meta name="twitter:description" content="跨域一、什么是跨域浏览器的同源策略 1. 什么是同源策略及其限制内容同源策略是一种约定，它是浏览器最核心也是最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSRF等攻击。所谓同源是指”协议+域名+端口”三者相同，即便两个不同的域名指向同一个ip地址，也非同源。  同源策略限制内容有：  Cookie、LocalStorage、IndexedDB等存储性内容 DOM节点 AJAX请求">
<meta name="twitter:image" content="http://yoursite.com/2019/09/24/跨域/1638b3579d9eeb32.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"hide","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: 'T8XBOJJNFX',
      apiKey: '59ff9e3b216c019eeb2f6c073cef5a49',
      indexName: 'wulzt',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/09/24/跨域/">





  <title>跨域 | kowukowuko</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">kowukowuko</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">move now</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  
  <div class="algolia-popup popup search-popup">
    <div class="algolia-search">
      <div class="algolia-search-input-icon">
        <i class="fa fa-search"></i>
      </div>
      <div class="algolia-search-input" id="algolia-search-input"></div>
    </div>

    <div class="algolia-results">
      <div id="algolia-stats"></div>
      <div id="algolia-hits"></div>
      <div id="algolia-pagination" class="algolia-pagination"></div>
    </div>

    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
  </div>




    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/24/跨域/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LZT">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kowukowuko">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">跨域</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-24T20:42:00+08:00">
                2019-09-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h1><h2 id="一、什么是跨域"><a href="#一、什么是跨域" class="headerlink" title="一、什么是跨域"></a>一、什么是跨域</h2><p>浏览器的同源策略</p>
<h3 id="1-什么是同源策略及其限制内容"><a href="#1-什么是同源策略及其限制内容" class="headerlink" title="1. 什么是同源策略及其限制内容"></a>1. 什么是同源策略及其限制内容</h3><p>同源策略是一种约定，它是浏览器最核心也是最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSRF等攻击。所谓同源是指”协议+域名+端口”三者相同，即便两个不同的域名指向同一个ip地址，也非同源。</p>
<p><img src="1638b3579d9eeb32.png" alt="alt"></p>
<p>同源策略限制内容有：</p>
<ul>
<li>Cookie、LocalStorage、IndexedDB等存储性内容</li>
<li>DOM节点</li>
<li>AJAX请求发送后，结果被浏览器拦截了</li>
</ul>
<p>但有三个标签是允许跨域加载资源：</p>
<ul>
<li>img</li>
<li>link</li>
<li>script</li>
</ul>
<h3 id="2-常见跨域场景"><a href="#2-常见跨域场景" class="headerlink" title="2. 常见跨域场景"></a>2. 常见跨域场景</h3><p><em>当协议、子域名、主域名、端口号中任意一个不相同时，都算作不同域</em>。不同域之间相互请求资源，就算作“跨域”。常见跨域场景如下图所示：</p>
<p><img src="1638b3579dde630e.png" alt="alt"></p>
<p>说明两点<br>一、 如果是协议和端口造成的跨域问题前端无能为力<br>二、在跨域问题上，仅仅是通过“URL的首部”来识别而不会根据域名对应的IP地址是否相同来判断。“URL的首部”可以理解为“协议，域名和端口必须匹配</p>
<p>问：请求跨域了，那么请求到底发出去没有？</p>
<blockquote>
<p><em>跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了</em>。你可能会疑问明明通过表单的方式可以发起跨域请求，为什么 Ajax 就不会?因为归根结底，<em>跨域是为了阻止用户读取到另一个域名下的内容</em>，Ajax 可以获取响应，浏览器认为这不安全，所以拦截了响应。但是表单并不会获取新的内容，所以可以发起跨域请求。同时也说明了跨域并不能完全阻止 CSRF，因为请求毕竟是发出去了。</p>
</blockquote>
<h2 id="二、-跨域解决方案"><a href="#二、-跨域解决方案" class="headerlink" title="二、 跨域解决方案"></a>二、 跨域解决方案</h2><h3 id="1-jsonp"><a href="#1-jsonp" class="headerlink" title="1. jsonp"></a>1. jsonp</h3><p>1) 原理： 利用<code>&lt;script&gt;</code>标签没有跨域限制的漏洞，网页可以得到从其他来源动态产生的JSON数据。JSONP请求一定需要对方的服务器做支持才可以</p>
<p>2) JSONP和AJAX对比<br>JSONP和AJAX相同，都是客户端向服务器发送请求，从服务器获取数据的方式。但AJAX属于同源策略，JSONP属于非同源策略（跨域请求）</p>
<p>3) JSONP优缺点<br>JSONP优点时简单兼容性好，可用于解决主流浏览器的跨域数据访问的问题。缺点时仅支持<code>get</code>方法，具有局限性，不安全可能会遭受XSS攻击</p>
<p>4) JSONP的实现流程</p>
<ul>
<li>声明一个回调函数，其函数名（如show）当作参数值，要传递给跨域请求数据的服务器，函数形参为要获取目标数据（服务器返回的data）</li>
<li>创建一个<code>&lt;script&gt;</code>标签，把那个跨域的API数据接口地址，赋值给script的src，还要在这个地址中向服务器传递该函数名（可以通过问号传参: ?callback=show）</li>
<li>服务器接收到请求后，需要进行特殊的处理： 把传递进来的函数名和它需要给你的数据拼接成一个字符串，例如: 传递进去的函数名是show，它准备好的数据是show(‘hhh’)</li>
<li>最后服务器把准备的数据通过HTTP协议返回给客户端，客户端再调用执行之前的声明的回调函数（show），对返回的数据进行操作</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// index.html</span><br><span class="line">function jsonp(&#123; url, params, callback &#125;) &#123;</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    let script = document.createElement(&apos;script&apos;)</span><br><span class="line">    window[callback] = function(data) &#123;</span><br><span class="line">      resolve(data)</span><br><span class="line">      document.body.removeChild(script)</span><br><span class="line">    &#125;</span><br><span class="line">    params = &#123; ...params, callback &#125; // wd=b&amp;callback=show</span><br><span class="line">    let arrs = []</span><br><span class="line">    for (let key in params) &#123;</span><br><span class="line">      arrs.push(`$&#123;key&#125;=$&#123;params[key]&#125;`)</span><br><span class="line">    &#125;</span><br><span class="line">    script.src = `$&#123;url&#125;?$&#123;arrs.join(&apos;&amp;&apos;)&#125;`</span><br><span class="line">    document.body.appendChild(script)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">jsonp(&#123;</span><br><span class="line">  url: &apos;http://localhost:3000/say&apos;,</span><br><span class="line">  params: &#123; wd: &apos;Iloveyou&apos; &#125;,</span><br><span class="line">  callback: &apos;show&apos;</span><br><span class="line">&#125;).then(data =&gt; &#123;</span><br><span class="line">  console.log(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>5) jQuery的jsonp形式<br>JSONP都是GET和异步请求的，不存在其他的请求方式和同步请求，且jQuery默认就会给JSONP的请求清除缓存</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">	url:&quot;http://crossdomain.com/jsonServerResponse&quot;,</span><br><span class="line">	dataType:&quot;jsonp&quot;,</span><br><span class="line">	type:&quot;get&quot;,//可以省略</span><br><span class="line">	jsonpCallback:&quot;show&quot;,//-&gt;自定义传递给服务器的函数名，而不是使用jQuery自动生成的，可省略</span><br><span class="line">	jsonp:&quot;callback&quot;,//-&gt;把传递函数名的那个形参callback，可省略</span><br><span class="line">	success:function (data)&#123;</span><br><span class="line">		console.log(data);&#125;</span><br><span class="line">	&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="2-cors"><a href="#2-cors" class="headerlink" title="2. cors"></a>2. cors</h3><p>CORS需要浏览器和后端同时支持。IE 8 和 9 需要通过 XDomainRequest 来实现。</p>
<p>浏览器会自动进行CORS通信，实现CORS通信的关键是后端。只要后端实现了CORS，就实现了跨域</p>
<p>服务端设置<code>Access-Control-Allow-Origin</code>就可以开启CORS。该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源</p>
<p>虽然设置CORS和前端没啥关系，但通过这种方式解决跨域问题的话，会在发送请求时出现两种情况，分别为简单请求和复杂请求</p>
<p>1) 简单请求<br>只要同时满足以下两大条件，就属于简单请求</p>
<p>条件一： 使用下列方法之一：</p>
<ul>
<li>GET</li>
<li>HEAD</li>
<li>POST<br>条件二： Content-Type的值仅限于下列三者之一：</li>
<li>text/plain</li>
<li>multipart/form-data</li>
<li>application/x-www-form-urlencoded</li>
</ul>
<p>2) 复杂请求<br>不符合以上条件的请求就肯定是复杂请求了。复杂请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为“预检”请求，该请求是option方法的，通过该请求来知道服务端是否允许跨域请求</p>
<p>我们用PUT向后台请求时，属于复杂请求，后台需要做如下配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 允许哪个方法访问我</span><br><span class="line">res.setHeader(&apos;Access-Control-Allow-Methods&apos;, &apos;PUT&apos;)</span><br><span class="line">// 预检的存活时间</span><br><span class="line">res.setHeader(&apos;Access-Control-Max-Age&apos;, 6)</span><br><span class="line">// OPTIONS请求不做任何处理</span><br><span class="line">if (req.method === &apos;OPTIONS&apos;) &#123;</span><br><span class="line">  res.end() </span><br><span class="line">&#125;</span><br><span class="line">// 定义后台返回的内容</span><br><span class="line">app.put(&apos;/getData&apos;, function(req, res) &#123;</span><br><span class="line">  console.log(req.headers)</span><br><span class="line">  res.end(&apos;我不爱你&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="postMessage"><a href="#postMessage" class="headerlink" title="postMessage"></a>postMessage</h3><p>postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题</p>
<ul>
<li>页面和其打开的新窗口的数据传递</li>
<li>多窗口之间消息传递</li>
<li>页面与嵌套的iframe消息传递</li>
<li>上面三个场景的跨域数据传递</li>
</ul>
<p>postMessage()方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递</p>
<blockquote>
<p>otherWindow.postMessage(message.targetOrigin,[transfer])</p>
<ul>
<li>message: 将要发送到其他 window的数据。</li>
<li>targetOrigin:通过窗口的origin属性来指定哪些窗口能接收到消息事件，其值可以是字符串”*”（表示无限制）或者一个URI。在发送消息的时候，如果目标窗口的协议、主机地址或端口这三者的任意一项不匹配targetOrigin提供的值，那么消息就不会被发送；只有三者完全匹配，消息才会被发送。</li>
<li>transfer(可选)：是一串和message 同时传递的 Transferable 对象. 这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。</li>
</ul>
</blockquote>
<p>//没看懂 下一个</p>
<h3 id="websocket"><a href="#websocket" class="headerlink" title="websocket"></a>websocket</h3><p>Websocket是HTML5的一个持久化的协议，它实现了浏览器与服务器的全双工通信，同时也是跨域的一种解决方案。WebSocket和HTTP都是应用层协议，都基于TCP协议。但是WebSocket是一种双向通信协议，在建立连接后，WebSocket的server与client都能主动向对方发送或接收数据。同时，WebSocket在建立连接时需要借助HTTP协议，连接建立好了之后client与server之间的双向通信就与HTTP无关</p>
<p>原生WebSocket API使用起来不太方便，我们使用Socket.io，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。</p>
<p>我们先来看个例子：本地文件socket.html向localhost:3000发生数据和接受数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// socket.html</span><br><span class="line">`&lt;script&gt;`</span><br><span class="line">    let socket = new WebSocket(&apos;ws://localhost:3000&apos;);</span><br><span class="line">    socket.onopen = function () &#123;</span><br><span class="line">      socket.send(&apos;我爱你&apos;);//向服务器发送数据</span><br><span class="line">    &#125;</span><br><span class="line">    socket.onmessage = function (e) &#123;</span><br><span class="line">      console.log(e.data);//接收服务器返回的数据</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// server.js</span><br><span class="line">let express = require(&apos;express&apos;);</span><br><span class="line">let app = express();</span><br><span class="line">let WebSocket = require(&apos;ws&apos;);//记得安装ws</span><br><span class="line">let wss = new WebSocket.Server(&#123;port:3000&#125;);</span><br><span class="line">wss.on(&apos;connection&apos;,function(ws) &#123;</span><br><span class="line">  ws.on(&apos;message&apos;, function (data) &#123;</span><br><span class="line">    console.log(data);</span><br><span class="line">    ws.send(&apos;我不爱你&apos;)</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="Node中间件代理"><a href="#Node中间件代理" class="headerlink" title="Node中间件代理"></a>Node中间件代理</h3><p>实现原理： <em>同源策略是浏览器需要遵循的标准，而如果是服务器向服务器请求就无需遵循同源策略。</em>代理服务器需要做以下步骤：</p>
<ul>
<li>接受客户端请求</li>
<li>将请求转发给服务器</li>
<li>拿到服务器响应数据</li>
<li>将响应转发给客户端</li>
</ul>
<p>我们先来看个例子：本地文件index.html文件，通过代理服务器<code>http://localhost:3000</code>向目标服务器<code>http://localhost:4000</code>请求数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// index.html(http://127.0.0.1:5500)</span><br><span class="line"> &lt;script src=&quot;https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    `&lt;script&gt;`</span><br><span class="line">      $.ajax(&#123;</span><br><span class="line">        url: &apos;http://localhost:3000&apos;,</span><br><span class="line">        type: &apos;post&apos;,</span><br><span class="line">        data: &#123; name: &apos;xiamen&apos;, password: &apos;123456&apos; &#125;,</span><br><span class="line">        contentType: &apos;application/json;charset=utf-8&apos;,</span><br><span class="line">        success: function(result) &#123;</span><br><span class="line">          console.log(result) // &#123;&quot;title&quot;:&quot;fontend&quot;,&quot;password&quot;:&quot;123456&quot;&#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        error: function(msg) &#123;</span><br><span class="line">          console.log(msg)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">     &lt;/script&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">// server1.js 代理服务器(http://localhost:3000)</span><br><span class="line">const http = require(&apos;http&apos;)</span><br><span class="line">// 第一步：接受客户端请求</span><br><span class="line">const server = http.createServer((request, response) =&gt; &#123;</span><br><span class="line">  // 代理服务器，直接和浏览器直接交互，需要设置CORS 的首部字段</span><br><span class="line">  response.writeHead(200, &#123;</span><br><span class="line">    &apos;Access-Control-Allow-Origin&apos;: &apos;*&apos;,</span><br><span class="line">    &apos;Access-Control-Allow-Methods&apos;: &apos;*&apos;,</span><br><span class="line">    &apos;Access-Control-Allow-Headers&apos;: &apos;Content-Type&apos;</span><br><span class="line">  &#125;)</span><br><span class="line">  // 第二步：将请求转发给服务器</span><br><span class="line">  const proxyRequest = http</span><br><span class="line">    .request(</span><br><span class="line">      &#123;</span><br><span class="line">        host: &apos;127.0.0.1&apos;,</span><br><span class="line">        port: 4000,</span><br><span class="line">        url: &apos;/&apos;,</span><br><span class="line">        method: request.method,</span><br><span class="line">        headers: request.headers</span><br><span class="line">      &#125;,</span><br><span class="line">      serverResponse =&gt; &#123;</span><br><span class="line">        // 第三步：收到服务器的响应</span><br><span class="line">        var body = &apos;&apos;</span><br><span class="line">        serverResponse.on(&apos;data&apos;, chunk =&gt; &#123;</span><br><span class="line">          body += chunk</span><br><span class="line">        &#125;)</span><br><span class="line">        serverResponse.on(&apos;end&apos;, () =&gt; &#123;</span><br><span class="line">          console.log(&apos;The data is &apos; + body)</span><br><span class="line">          // 第四步：将响应结果转发给浏览器</span><br><span class="line">          response.end(body)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">    .end()</span><br><span class="line">&#125;)</span><br><span class="line">server.listen(3000, () =&gt; &#123;</span><br><span class="line">  console.log(&apos;The proxyServer is running at http://localhost:3000&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// server2.js(http://localhost:4000)</span><br><span class="line">const http = require(&apos;http&apos;)</span><br><span class="line">const data = &#123; title: &apos;fontend&apos;, password: &apos;123456&apos; &#125;</span><br><span class="line">const server = http.createServer((request, response) =&gt; &#123;</span><br><span class="line">  if (request.url === &apos;/&apos;) &#123;</span><br><span class="line">    response.end(JSON.stringify(data))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">server.listen(4000, () =&gt; &#123;</span><br><span class="line">  console.log(&apos;The server is running at http://localhost:4000&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="6-nginx反向代理"><a href="#6-nginx反向代理" class="headerlink" title="6. nginx反向代理"></a>6. nginx反向代理</h3><p>实现原理类似于Node中间件代理，需要你搭建一个中转nginx服务器，用于转发请求</p>
<p>使用nginx反向代理实现跨域，是最简单的跨域方式。只需要修改nginx的配置即可解决跨域问题，支持所有浏览器，支持session，不需要修改任何代码，并且不会影响服务器性能</p>
<p>实现思路： 通过nginx配置一个代理服务器（域名与domain1相同，端口不用）做跳板机，反向代理访问访问domain2接口，并且可以顺便修改cookie中的domain信息，方便当前域cookie写入，实现跨域登陆</p>
<p>先下载 <a href="https://link.juejin.im/?target=http%3A%2F%2Fnginx.org%2Fen%2Fdownload.html" target="_blank" rel="noopener">nginx</a> ，然后将nginx目录下的nginx.conf修改如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// proxy服务器</span><br><span class="line">server &#123;</span><br><span class="line">    listen       81;</span><br><span class="line">    server_name  www.domain1.com;</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass   http://www.domain2.com:8080;  #反向代理</span><br><span class="line">        proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line"></span><br><span class="line">        # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用</span><br><span class="line">        add_header Access-Control-Allow-Origin http://www.domain1.com;  #当前端只跨域不带cookie时，可为*</span><br><span class="line">        add_header Access-Control-Allow-Credentials true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后通过命令行<code>nginx -s reload</code>启动nginx</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// index.html</span><br><span class="line">var xhr = new XMLHttpRequest();</span><br><span class="line">// 前端开关：浏览器是否读写cookie</span><br><span class="line">xhr.withCredentials = true;</span><br><span class="line">// 访问nginx中的代理服务器</span><br><span class="line">xhr.open(&apos;get&apos;, &apos;http://www.domain1.com:81/?user=admin&apos;, true);</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// server.js</span><br><span class="line">var http = require(&apos;http&apos;);</span><br><span class="line">var server = http.createServer();</span><br><span class="line">var qs = require(&apos;querystring&apos;);</span><br><span class="line">server.on(&apos;request&apos;, function(req, res) &#123;</span><br><span class="line">    var params = qs.parse(req.url.substring(2));</span><br><span class="line">    // 向前台写cookie</span><br><span class="line">    res.writeHead(200, &#123;</span><br><span class="line">        &apos;Set-Cookie&apos;: &apos;l=a123456;Path=/;Domain=www.domain2.com;HttpOnly&apos;   // HttpOnly:脚本无法读取</span><br><span class="line">    &#125;);</span><br><span class="line">    res.write(JSON.stringify(params));</span><br><span class="line">    res.end();</span><br><span class="line">&#125;);</span><br><span class="line">server.listen(&apos;8080&apos;);</span><br><span class="line">console.log(&apos;Server is running at port 8080...&apos;);</span><br></pre></td></tr></table></figure>

<p>#前端  #blog</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/09/12/常见六大Web安全攻防解析/" rel="next" title="常见六大Web安全攻防解析">
                <i class="fa fa-chevron-left"></i> 常见六大Web安全攻防解析
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/10/17/事件循环EventLoop/" rel="prev" title="事件循环EventLoop">
                事件循环EventLoop <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">LZT</p>
              <p class="site-description motion-element" itemprop="description">ㅋㅋㅋㅋㅋ</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">17</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#跨域"><span class="nav-number">1.</span> <span class="nav-text">跨域</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#一、什么是跨域"><span class="nav-number">1.1.</span> <span class="nav-text">一、什么是跨域</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-什么是同源策略及其限制内容"><span class="nav-number">1.1.1.</span> <span class="nav-text">1. 什么是同源策略及其限制内容</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-常见跨域场景"><span class="nav-number">1.1.2.</span> <span class="nav-text">2. 常见跨域场景</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二、-跨域解决方案"><span class="nav-number">1.2.</span> <span class="nav-text">二、 跨域解决方案</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-jsonp"><span class="nav-number">1.2.1.</span> <span class="nav-text">1. jsonp</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-cors"><span class="nav-number">1.2.2.</span> <span class="nav-text">2. cors</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#postMessage"><span class="nav-number">1.2.3.</span> <span class="nav-text">postMessage</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#websocket"><span class="nav-number">1.2.4.</span> <span class="nav-text">websocket</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Node中间件代理"><span class="nav-number">1.2.5.</span> <span class="nav-text">Node中间件代理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-nginx反向代理"><span class="nav-number">1.2.6.</span> <span class="nav-text">6. nginx反向代理</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">LZT</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  




  
  
  
  <link rel="stylesheet" href="/lib/algolia-instant-search/instantsearch.min.css">

  
  
  <script src="/lib/algolia-instant-search/instantsearch.min.js"></script>
  

  <script src="/js/src/algolia-search.js?v=5.1.4"></script>



  

  

  

  
  

  

  

  

</body>
</html>
