<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>Hexo</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/05/闭包/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/05/闭包/" itemprop="url">闭包</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-07-05T15:49:25+08:00">
                2019-07-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p>闭包是指其所在执行上下文已经出栈，但仍访问了其所在执行上下文变量对象的函数。</p>
<p>JavaScript 拥有自动的垃圾回收机制，当一个值失去引用的时候，垃圾回收机制会根据特殊的算法找到它并将其回收。</p>
<p><strong>函数的执行上下文在出栈后，其变量对象会失去引用等待被回收，而闭包的存在会阻止这一过程，因为闭包的作用域链包含了其所在执行上下文的变量对象。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var a = 1;</span><br><span class="line">function fn1()&#123;</span><br><span class="line">    var b = 2;</span><br><span class="line">    function fn2()&#123;</span><br><span class="line">        return b;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return fn2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var fn2=fn1();</span><br><span class="line">fn2();</span><br></pre></td></tr></table></figure>

<p>在代码执行过程中，执行上下文栈的行为如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/*伪代码*/</span><br><span class="line">// 代码执行时最先进入全局环境，全局上下文被创建并入栈</span><br><span class="line">ECStack.push(globalContext);</span><br><span class="line">// fn1 被调用，fn1 函数上下文被创建并入栈</span><br><span class="line">ECStack.push(&lt;fn1&gt; functionContext);</span><br><span class="line">// fn1 执行完毕，fn1 函数上下文出栈</span><br><span class="line">ECStack.pop();</span><br><span class="line">// fn2 被调用，fn2 函数上下文被创建并入栈</span><br><span class="line">ECStack.push(&lt;fn2&gt; functionContext);</span><br><span class="line">// fn2 执行完毕，fn2 函数上下文出栈</span><br><span class="line">ECStack.pop();</span><br><span class="line">// 代码执行完毕，全局上下文出栈</span><br><span class="line">ECStack.pop();</span><br></pre></td></tr></table></figure>

<p>从执行上下文栈的行为我们可知，在 fn2 函数执行的时候，其实 fn1 上下文已经出栈了，按照 javascript 的垃圾回收机制，fn1 上下文的变量对象失去引用后会被垃圾回收机制回收，但由于在 fn2 上下文的作用域链包含了 fn1 上下文的变量对象，所以 fn1 上下文的变量对象不会被垃圾回收机制回收。</p>
<ul>
<li><input disabled type="checkbox"> 经典闭包问题<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var arr = [];</span><br><span class="line">for (var i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">    arr[i] = function () &#123;</span><br><span class="line">        console.log(i);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">arr[0]();</span><br><span class="line">arr[1]();</span><br><span class="line">arr[2]();</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>三个函数输出都是3</p>
<blockquote>
<p>for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。  </p>
</blockquote>
<p>在 arr[0] 函数执行之前，我们可以知道，全局上下文的变量对象如下所示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">globalContext = &#123;</span><br><span class="line">    VO: &#123;</span><br><span class="line">        arr: [...],</span><br><span class="line">        i: 3</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据作用域链，arr[0] 函数会现在自身的变量对象中寻找 i ，如果找不到，会到全局上下文变量对象中寻找 i，所以最终输出 3</p>
<p>经典解决方法（立即执行函数）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var arr = [];</span><br><span class="line">for (var i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">    arr[i] = (function (i) &#123;</span><br><span class="line">        return function()&#123;</span><br><span class="line">            console.log(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">arr[0]();  //  0</span><br><span class="line">arr[1]();  //  1</span><br><span class="line">arr[2]();  //  2</span><br></pre></td></tr></table></figure>

<p>其作用域链发生了变化，arr[0] 的变量对象之后紧跟着匿名函数的变量对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">匿名函数Context = &#123;</span><br><span class="line">    VO: &#123;</span><br><span class="line">        Arguments:&#123;</span><br><span class="line">            0:0,</span><br><span class="line">            length:1</span><br><span class="line">        &#125;,</span><br><span class="line">        i: 0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://segmentfault.com/a/1190000003985390" target="_blank" rel="noopener">关于立即执行函数</a><br><strong>立即调用的函数表达式可以用来锁定值并且有效的保存此时的状态</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">// 它的运行原理可能并不像你想的那样，因为`i`的值从来没有被锁定。</span><br><span class="line">// 相反的，每个链接，当被点击时（循环已经被很好的执行完毕），因此会弹出所有元素的总数，</span><br><span class="line">// 因为这是 `i` 此时的真实值。</span><br><span class="line"></span><br><span class="line">var elems = document.getElementsByTagName(&apos;a&apos;);</span><br><span class="line">for(var i = 0;i &lt; elems.length; i++ ) &#123;</span><br><span class="line">    elems[i].addEventListener(&apos;click&apos;,function(e)&#123;</span><br><span class="line">        e.preventDefault();</span><br><span class="line">        alert(&apos;I am link #&apos; + i)</span><br><span class="line">        &#125;,false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 而像下面这样改写，便可以了，因为在IIFE里，`i`值被锁定在了`lockedInIndex`里。</span><br><span class="line">// 在循环结束执行时，尽管`i`值的数值是所有元素的总和，但每一次函数表达式被调用时，</span><br><span class="line">// IIFE 里的 `lockedInIndex` 值都是`i`传给它的值,所以当链接被点击时，正确的值被弹出。</span><br><span class="line"></span><br><span class="line">var elems = document.getElementsByTagName(&apos;a&apos;);</span><br><span class="line">for(var i = 0;i &lt; elems.length;i++) &#123;</span><br><span class="line">    (function(lockedInIndex)&#123;</span><br><span class="line">        elems[i].addEventListener(&apos;click&apos;,function(e)&#123;</span><br><span class="line">            e.preventDefault();</span><br><span class="line">            alert(&apos;I am link #&apos; + lockedInIndex);</span><br><span class="line">            &#125;,false)</span><br><span class="line">    &#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//你同样可以像下面这样使用IIFE，仅仅只用括号包括点击处理函数，并不包含整个`addEventListener`。</span><br><span class="line">//无论用哪种方式，这两个例子都可以用IIFE将值锁定，不过我发现前面一个例子更可读</span><br><span class="line"></span><br><span class="line">var elems = document.getElementsByTagName( &apos;a&apos; );</span><br><span class="line"></span><br><span class="line">for ( var i = 0; i &lt; elems.length; i++ ) &#123;</span><br><span class="line">    elems[ i ].addEventListener( &apos;click&apos;, (function( lockedInIndex )&#123;</span><br><span class="line">        return function(e)&#123;</span><br><span class="line">            e.preventDefault();</span><br><span class="line">            alert( &apos;I am link #&apos; + lockedInIndex );</span><br><span class="line">        &#125;;</span><br><span class="line">        &#125;)( i ),false);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://juejin.im/post/5b3ae7b8f265da62cb1db9e0" target="_blank" rel="noopener">闭包详解</a></p>
<p>#暑假培训</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/05/运输层/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/05/运输层/" itemprop="url">运输层</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-07-05T15:49:25+08:00">
                2019-07-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h1><h2 id="1-运输层协议概述"><a href="#1-运输层协议概述" class="headerlink" title="1. 运输层协议概述"></a>1. 运输层协议概述</h2><p>1.1 概述<br>运输层为相互通信的应用进程提供了逻辑通信<br><img src="%E8%BF%90%E8%BE%93%E5%B1%82/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-26%20%E4%B8%8B%E5%8D%881.32.20.png" alt><br><img src="%E8%BF%90%E8%BE%93%E5%B1%82/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-26%20%E4%B8%8B%E5%8D%881.32.27.png" alt></p>
<ul>
<li>两个主机进行通信实际上就是两个主机中的应用进程互相通信。 </li>
<li>应用进程之间的通信又称为端到端的通信。 </li>
<li>运输层的一个很重要的功能就是复用和分用。应用层不同进程的报文通过不同的端口向下交到运输层，再往下就共用网络层提供的服务。</li>
</ul>
<p>主要<strong>功能</strong>：</p>
<blockquote>
<p>运输层为应用进程之间提供端到端的逻辑通信（但网络层是为主机之间提供逻辑通信）。<br>运输层还要对收到的报文进行差错检测。<br>运输层需要有两种不同的运输协议，即面向连接的 TCP 和无连接的 UDP。  </p>
</blockquote>
<p>1.2 运输层的两个主要协议<br>(1) 用户数据报协议 UDP                 (User Datagram Protocol)<br>(2) 传输控制协议 TCP         (Transmission Control Protocol)</p>
<p>1.3 运输层的端口<br><strong>运输层主要是处理进程之间的通信的，而端口就代表了进程</strong>。</p>
<ol>
<li>端口用一个 16 位端口号进行标志。</li>
<li>端口号<strong>只具有本地意义，即端口号只是为了标志本计算机应用层中的各进程。</strong></li>
</ol>
<h2 id="2-用户数据报协议-UDP"><a href="#2-用户数据报协议-UDP" class="headerlink" title="2. 用户数据报协议 UDP"></a>2. 用户数据报协议 UDP</h2><p>UDP 只在 IP 的数据报服务之上增加了很少一点的功能：</p>
<ol>
<li>复用和分用的功能</li>
<li>差错检测的功能</li>
</ol>
<ul>
<li>传送的数据单位协议是 UDP 报文或用户数据报。</li>
</ul>
<p>特点：</p>
<ul>
<li>UDP 是无连接的，即发送数据之前不需要建立连接。</li>
<li>UDP 使用尽最大努力交付，即不保证可靠交付，同时也不使用拥塞控制。</li>
<li>UDP 是面向报文的。UDP 没有拥塞控制，很适合多媒体通信的要求。 </li>
<li>UDP 支持一对一、一对多、多对一和多对多的交互通信。</li>
<li>UDP 的首部开销小，只有 8 个字节。</li>
</ul>
<p>面向报文：</p>
<ul>
<li>发送方 UDP 对应用程序交下来的报文，在添加首部后就向下交付 IP 层。UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。</li>
<li>应用层交给 UDP 多长的报文，UDP 就照样发送，即一次发送一个报文。</li>
<li>应用程序必须选择合适大小的报文。</li>
</ul>
<h2 id="3-传输控制协议-TCP"><a href="#3-传输控制协议-TCP" class="headerlink" title="3. 传输控制协议 TCP"></a>3. 传输控制协议 TCP</h2><p>3.1 特点</p>
<ul>
<li>TCP 是面向连接的运输层协议。</li>
<li>每一条 TCP 连接只能有两个端点(endpoint)，每一条 TCP 连接只能是点对点的（一对一）。 </li>
<li>TCP 提供可靠交付的服务。</li>
<li>TCP 提供全双工通信。</li>
<li>面向字节流。 </li>
</ul>
<p>面向字节流</p>
<ul>
<li>TCP 中的“流”(stream)指的是流入或流出进程的字节序列。</li>
<li>“面向字节流”的含义是：虽然应用程序和 TCP 的交互是一次一个数据块，<em>但 TCP 把应用程序交下来的数据看成仅仅是一连串无结构的字节流。</em></li>
<li>接收方应用程序收到的字节流必须和发送方应用程序发出的字节流完全一样。</li>
</ul>
<p><img src="%E8%BF%90%E8%BE%93%E5%B1%82/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-26%20%E4%B8%8B%E5%8D%881.56.43.png" alt></p>
<p>TCP 报文段是在<strong>运输层抽象的端到端逻辑信道中传送</strong>，这种信道是可靠的全双工信道。但这样的<strong>信道却不知道究竟经过了哪些路由器，而这些路由器也根本不知道上面的运输层是否建立了 TCP 连接。</strong></p>
<p>注意：</p>
<ul>
<li>TCP 连接是一条<strong>虚连接</strong>而不是一条真正的物理连接。</li>
<li>TCP 对应用进程<strong>一次把多长的报文发送到TCP 的缓存中是不关心的</strong>。</li>
<li>TCP 根据对方给出的<strong>窗口值和当前网络拥塞的程度来决定一个报文段应包含多少个字节（UDP 发送的报文长度是应用进程给出的）</strong></li>
</ul>
<p>3.2 TCP的连接</p>
<ul>
<li>TCP 把连接作为最基本的抽象。</li>
<li>每一条 TCP 连接有两个端点。</li>
<li>TCP 连接的端点不是主机，不是主机的IP 地址，不是应用进程，也不是运输层的协议端口。TCP 连接的端点叫做套接字(socket)或插口。</li>
<li>端口号拼接到IP 地址即构成了<strong>套接字</strong>。   
<img src="%E8%BF%90%E8%BE%93%E5%B1%82/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-26%20%E4%B8%8B%E5%8D%882.01.14.png" alt></li>
</ul>
<h2 id="4-可靠传输的工作原理"><a href="#4-可靠传输的工作原理" class="headerlink" title="4. 可靠传输的工作原理"></a>4. 可靠传输的工作原理</h2><p>4.1 停止等待协议<br><strong>“停止等待”就是每发送完一个分组就停止发送，等待对方的确认。在收到确认后再发送下一个分组。</strong></p>
<ul>
<li>A 为每一个已发送的分组都设置了一个<strong>超时计时器</strong>。</li>
<li>A 只要在超时计时器到期之前收到了相应的确认，就撤销该超时计时器，继续发送下一个分组 M2 。<br><img src="%E8%BF%90%E8%BE%93%E5%B1%82/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-26%20%E4%B8%8B%E5%8D%882.04.47.png" alt><br>值得注意的是：</li>
<li><strong>在发送完一个分组后，必须暂时保留已发送的分组的副本，以备重发。</strong></li>
<li><strong>分组和确认分组都必须进行编号。</strong></li>
<li>超时计时器的重传时间应当比数据在分组传输的平均往返时间更长一些。</li>
</ul>
<p>像上述的这种可靠传输协议常称为自动重传请求 ARQ (Automatic Repeat reQuest)。意思<strong>是重传的请求是自动进行的，接收方不需要请求发送方重传某个出错的分组。</strong></p>
<p><strong>为了提高传输效率，发送方可以不使用低效率的停止等待协议，而是采用流水线传输。</strong></p>
<blockquote>
<p>流水线传输就是发送方可连续发送多个分组，不必每发完一个分组就停顿下来等待对方的确认。这样可使信道上一直有数据不间断地传送。  </p>
</blockquote>
<p><img src="%E8%BF%90%E8%BE%93%E5%B1%82/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-26%20%E4%B8%8B%E5%8D%882.06.37.png" alt></p>
<p>4.2 连续 ARQ 协议 </p>
<ul>
<li>发送方维持的发送窗口，它的意义是：<strong>位于发送窗口内的分组都可连续发送出去，而不需要等待对方的确认。这样，信道利用率就提高了。</strong></li>
<li><strong>连续 ARQ 协议规定，发送方每收到一个确认，就把发送窗口向前滑动一个分组的位置。</strong></li>
</ul>
<p>即不必对收到的分组逐个发送确认，<strong>而是对按序到达的最后一个分组发送确认，这样就表示：到这个分组为止的所有分组都已正确收到了。</strong></p>
<p>优点：<strong>容易实现，即使确认丢失也不必重传。</strong> 缺点：<strong>不能向发送方反映出接收方已经正确收到的所有分组的信息。</strong></p>
<p>如果发送方发送了前 5 个分组，<strong>而中间的第 3 个分组丢失了</strong>。这时接收方只能对前两个分组发出确认。发送方无法知道后面三个分组的下落，而只好把后面的三个分组都再重传一次。 这就叫做 Go-back-N（回退 N），<strong>表示需要再退回来重传已发送过的 N 个分组。</strong></p>
<p>具体实现</p>
<blockquote>
<p>TCP 连接的每一端都必须设有两个窗口——一个发送窗口和一个接收窗口。 TCP 的可靠传输机制用字节的序号进行控制。TCP 所有的确认都是基于序号而不是基于报文段。 TCP 两端的四个窗口经常处于动态变化之中。 TCP连接的往返时间 RTT 也不是固定不变的。需要使用特定的算法估算较为合理的重传时间。<br><img src="%E8%BF%90%E8%BE%93%E5%B1%82/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-26%20%E4%B8%8B%E5%8D%882.22.05.png" alt></p>
</blockquote>
<h2 id="5-TCP-报文段的首部格式"><a href="#5-TCP-报文段的首部格式" class="headerlink" title="5. TCP 报文段的首部格式"></a>5. TCP 报文段的首部格式</h2><p><img src="%E8%BF%90%E8%BE%93%E5%B1%82/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-26%20%E4%B8%8B%E5%8D%882.24.12.png" alt></p>
<h2 id="6-TCP-可靠传输的实现"><a href="#6-TCP-可靠传输的实现" class="headerlink" title="6. TCP 可靠传输的实现"></a>6. TCP 可靠传输的实现</h2><p>6.2 超时重传时间RTO</p>
<ul>
<li><input disabled type="checkbox"> 加权平均往返时间RTTS</li>
</ul>
<ul>
<li>TCP 保留了 RTT 的一个加权平均往返时间 RTTS（这又称为平滑的往返时间）</li>
<li>第一次测量到 RTT 样本时，RTTS 值就取为所测量到的 RTT 样本值。以后每测量到一个新的 RTT 样本，就按下式重新计算一次 RTTS：<br><img src="%E8%BF%90%E8%BE%93%E5%B1%82/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-26%20%E4%B8%8B%E5%8D%882.39.34.png" alt></li>
</ul>
<ul>
<li><input disabled type="checkbox"> RTTD 是 RTT 的偏差的加权平均值<br><img src="%E8%BF%90%E8%BE%93%E5%B1%82/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-26%20%E4%B8%8B%E5%8D%882.39.59.png" alt></li>
<li><input disabled type="checkbox"> 超时重传时间 RTO<br><img src="%E8%BF%90%E8%BE%93%E5%B1%82/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-26%20%E4%B8%8B%E5%8D%882.39.50.png" alt></li>
</ul>
<ul>
<li>修正的 Karn 算法<br><img src="%E8%BF%90%E8%BE%93%E5%B1%82/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-26%20%E4%B8%8B%E5%8D%882.42.04.png" alt></li>
</ul>
<p>6.3 选择确认 SACK</p>
<ul>
<li>接收方收到了和前面的字节流不连续的两个字节块。</li>
<li>如果这些字节的序号都在接收窗口之内，那么接收方就先收下这些数据，但要把这些信息准确地告诉发送方，使发送方不要再重复发送这些已收到的数据。 </li>
</ul>
<h2 id="7-TCP的流量控制"><a href="#7-TCP的流量控制" class="headerlink" title="7. TCP的流量控制"></a>7. TCP的流量控制</h2><ul>
<li>流量控制(flow control)就是让发送方的发送速率不要太快，既要让接收方来得及接收，也不要使网络发生拥塞。</li>
</ul>
<p>利用滑动窗口实现流量控制<br><img src="%E8%BF%90%E8%BE%93%E5%B1%82/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-26%20%E4%B8%8B%E5%8D%882.48.33.png" alt></p>
<p>7.2 传输速率<br>可以用不同的机制来控制 TCP 报文段的发送时机:</p>
<ul>
<li>第一种机制是 TCP 维持一个变量，它等于最大报文段长度 MSS。只要缓存中存放的数据达到 MSS 字节时，就组装成一个 TCP 报文段发送出去。</li>
<li>第二种机制是由发送方的应用进程指明要求发送报文段，即 TCP 支持的推送(push)操作。</li>
<li>第三种机制是发送方的一个计时器期限到了，这时就把当前已有的缓存数据装入报文段（但长度不能超过 MSS）发送出去。</li>
</ul>
<h2 id="8-TCP-的拥塞控制"><a href="#8-TCP-的拥塞控制" class="headerlink" title="8. TCP 的拥塞控制"></a>8. TCP 的拥塞控制</h2><p>对资源需求的总和 &gt; 可用资源</p>
<p>几种拥堵控制的方法</p>
<ol>
<li><strong>慢开始和拥塞避免</strong></li>
</ol>
<ul>
<li>发送方维持一个叫做拥塞窗口 cwnd (congestion window)的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口。如再考虑到接收方的接收能力，则发送窗口还可能小于拥塞窗口。</li>
<li>发送方控制拥塞窗口的原则是：只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络中的分组数。</li>
</ul>
<p>慢开始算法的原理</p>
<blockquote>
<p>在主机刚刚开始发送报文段时可先设置拥塞窗口 cwnd = 1，即设置为一个最大报文段 SMSS 的数值。<br>在每收到一个对新的报文段的确认后，将拥塞窗口加 1，即增加一个 SMSS 的数值。<br>用这样的方法逐步增大发送端的拥塞窗口 cwnd，可以使分组注入到网络的速率更加合理。  </p>
</blockquote>
<p><img src="%E8%BF%90%E8%BE%93%E5%B1%82/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-26%20%E4%B8%8B%E5%8D%883.04.04.png" alt></p>
<p>设置慢开始门限状态变量ssthresh</p>
<ul>
<li><input disabled type="checkbox"> 慢开始门限 ssthresh 的用法如下：</li>
</ul>
<ul>
<li>当 cwnd &lt; ssthresh 时，使用慢开始算法。</li>
<li>当 cwnd &gt; ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。</li>
<li>当 cwnd = ssthresh 时，既可使用慢开始算法，也可使用拥塞避免算法。</li>
<li>拥塞避免算法的思路是让拥塞窗口 cwnd 缓慢地增大，即每经过一个往返时间 RTT 就把发送方的拥塞窗口 cwnd 加 1，而不是加倍，使拥塞窗口 cwnd 按线性规律缓慢增长。</li>
</ul>
<ul>
<li><input disabled type="checkbox"> 当网络出现拥堵</li>
</ul>
<ul>
<li>无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有按时收到确认），就要把慢开始门限 ssthresh 设置为出现拥塞时的发送方窗口值的一半（但不能小于2）。</li>
<li>然后把拥塞窗口 cwnd 重新设置为 1，执行慢开始算法。</li>
<li>这样做的目的就是要迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够时间把队列中积压的分组处理完毕。 </li>
</ul>
<ol start="2">
<li><strong>快重传和快恢复</strong></li>
</ol>
<ul>
<li><input disabled type="checkbox"> 快重传</li>
</ul>
<ul>
<li>快重传算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认。这样做可以让发送方及早知道有报文段没有到达接收方。 </li>
<li>发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段。 </li>
<li>不难看出，快重传并非取消重传计时器，而是在某些情况下可更早地重传丢失的报文段。<br><img src="%E8%BF%90%E8%BE%93%E5%B1%82/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-26%20%E4%B8%8B%E5%8D%883.10.21.png" alt></li>
</ul>
<ul>
<li><input disabled type="checkbox"> 快恢复<br>(1) 当发送端收到连续三个重复的确认时，就执行“乘法减小”算法，把慢开始门限 ssthresh 减半。但接下去不执行慢开始算法。<br>(2)由于发送方现在认为网络很可能没有发生拥塞，因此现在不执行慢开始算法，即拥塞窗口 cwnd 现在不设置为 1，而是设置为慢开始门限 ssthresh 减半后的数值，然后开始执行拥塞避免算法（“加法增大”），使拥塞窗口缓慢地线性增大。<br><img src="%E8%BF%90%E8%BE%93%E5%B1%82/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-26%20%E4%B8%8B%E5%8D%883.14.27.png" alt></li>
</ul>
<h2 id="9-TCP-的运输连接管理"><a href="#9-TCP-的运输连接管理" class="headerlink" title="9. TCP 的运输连接管理"></a>9. TCP 的运输连接管理</h2><p><strong>三次握手</strong></p>
<ul>
<li><p>1 客户端先发起连接请求报文（同步位SYN=1，初始序号seq=x,<strong>表明传送数据时的第一个数据字节的序号是 x</strong>）
客户端发出后状态变为同步发送状态（客户端：hello，你是服务端吗）</p>
</li>
<li><p>2 服务端在收到来自客户端的连接请求报文后，回报以确认链接报文（SYN=1，ACK=1，确认号ack=x+1，自己选择一个初始序号seq=y）服务端发出该报文后状态变为同步收到状态（服务端：hello，我是服务端，你是客户端吗）</p>
</li>
<li><p>3 客户端在接收到来自服务端的确认链接报文后，回报以确认连接报文（ACK=1，确认号ack = y+1,自己的序号seq=x+1）客户端发出该报文后状态变为已建立连接状态（客户端：我是客户端）（主要为了防止已失效的请求报文突然又传到了服务端，用以确认第一个请求报文是否有效,还有就是防止二次握手后服务端的报文没有成功送到客户端造成等待的死锁）</p>
</li>
</ul>
<p><img src="%E8%BF%90%E8%BE%93%E5%B1%82/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-26%20%E4%B8%8B%E5%8D%883.27.14.png" alt></p>
<p><strong>四次挥手</strong></p>
<ul>
<li>1 A方（可以是任意一方）发出连接释放报文（终止控制位FIN=1，序号seq=u（前面已传输数据最后一个字节序号+1））A方在发出该报文后进入终止等待1的状态（A方：我关闭了向你那边的主动通道）</li>
<li>2 B方接收到这个连接释放报文后，返回以一个确认报文（ACK=1，seq = v（前面已发送数据最后一字节序列号+1）ack = u+1）然后B方进入等待关闭状态，A接收到这个报文后进入终止等待2状态（之后，链接就进入半关闭状态，A不再发送信息，但可以接收）（B方：收到通道关闭信息）</li>
<li>3 B发送连接释放报文（FIN=1，ACK=1，seq=w（在半关闭状态下又可能传输了一些数据）ack=u+1）B发出这个报文后，进入最后确认状态（B：现在我也要关闭向你那边的主动通道了）</li>
<li>4 A收到B发送的连接释放报文，回报以确认报文（ACK=1，seq=u+1，ack=w+1）A发送这个报文后，进入一个时间等待状态，等一段时间后会自动关闭，B收到这个报文后，就进入关闭状态，双方都进入关闭状态，则TCP挥手完成（时间等待状态原因：不能确保最终的连接释放报文能成功送到B，仍需等待观望，还有就是防止已失效的报文又到达服务器，客户端在发送最后一个ACK之后，再经过经过2MSL（最长报文段寿命），就可以使本链接持续时间内所产生的所有报文段都从网络中消失。从保证在关闭连接后不会有还在网络中滞留的报文段去骚扰服务器。）</li>
</ul>
<p><img src="%E8%BF%90%E8%BE%93%E5%B1%82/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-26%20%E4%B8%8B%E5%8D%883.26.58.png" alt></p>
<p>#课内</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/05/网络层/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/05/网络层/" itemprop="url">网络层</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-07-05T15:49:25+08:00">
                2019-07-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><blockquote>
<p>网络层关注的是如何将分组从源端沿着网络路径送达目的端。 在计算机网络领域，网络层应该向运输层提供怎样的服务，也就是说，在计算机通信中，可靠交付应当由谁来负责？ 是网络还是端系统 注：答案是端系统负责，就是IP客户端和服务端，服务端发现包发错了，就会让客户端重发，如果是网络负责的话， 就是说客户端发到任何一个路由器，路由器还要检查包错没错，错了让客户端重发，这就特别耗时和耗资源。   </p>
</blockquote>
<h2 id="1-提供两种服务"><a href="#1-提供两种服务" class="headerlink" title="1.  提供两种服务"></a>1.  提供两种服务</h2><ul>
<li><input disabled type="checkbox"> <strong>虚拟电路服务</strong><br>虚拟电路表示一条逻辑上的链接，而不是建立一条真正的物理链接。请注意，电路交换的电话通信是先建立了一条 真正的连接。理解的话，相对于我们平时的路由器来看，路由器是根据自己的路由表，临时决定最佳的路径，不是 开始就定好了，虚电路服务就相当于开始就定好了，所以定好的路线如果有结点发生故障，就不能工作了。</li>
<li><input disabled type="checkbox"> <strong>数据报服务</strong><br>网络层向上只提供简单灵活的、无连接的、尽最大努力的数据报服务。网络在发送分组时不需要先建立连接。每 一个分组（即IP数据报）独立发送，与其前后的分组无关（不进行编号） 网络层不提供服务质量的承诺。即所传送的分组可能出错、丢失、重复和失序（不按顺序到达终点），当然也不 保证分组传送的时间限制</li>
</ul>
<h2 id="2-网际协议IP"><a href="#2-网际协议IP" class="headerlink" title="2. 网际协议IP"></a>2. 网际协议IP</h2><p><strong>2.1 虚拟互联网</strong></p>
<blockquote>
<p> 首先需要了解网络互联的设备<br>中间设备又称为中间系统或中继系统  </p>
<ul>
<li>物理层中继系统：集线器（hub）用来放大物理信号的  </li>
<li>数据链路层中继系统：网桥或交换机  </li>
<li>网络层中继系统： 路由器  </li>
<li>网络层以上的中继系统：网关（通常网关就是路由器的地址）  </li>
</ul>
</blockquote>
<blockquote>
<p>1、所谓虚拟互联网络，意思就是互相起来的各种物理网络的异构性本来就是客观存在的，但我们利用IP 协议就可以使这些性能各异的网络从用户看起来好像是一个统一的网络<br>2、使用ip协议的虚拟互联网络可以简称位ip网<br>3、与IP协议相关的网络还有<br>    3.1 地址解析协议 ARP<br>    3.2 逆地址解析协议 RARP<br>    3.3 网际控制协议ICMP<br>    3.4 网际组管理协议 IGMP  </p>
</blockquote>
<p><strong>2.2分类的IP地址</strong></p>
<ul>
<li>层次化IP地址</li>
</ul>
<blockquote>
<p>1、IPv4地址是32位，分为网络地址和主机地址<br>2、路由器只需要把信息发到指定的网段，而不用关心具体发到哪个计算机上<br>3、网络地址（可以称位网络号）唯一制定了每个网络。同一网络中的每台计算机都会共享相同的网络地址，并用它作为自己IP地址的一部分  </p>
</blockquote>
<ul>
<li>ABCD类网络地址</li>
</ul>
<p><img src="%E7%BD%91%E7%BB%9C%E5%B1%82/IP%E5%9C%B0%E5%9D%80.png" alt></p>
<blockquote>
<p>A类地址：网络号第1部分，也就是8位2进制是0打头。所以它的范围是1-127，这是A类地址的范围<br>B类地址：网络号第1部分，也就是8位2进制是10打头。所以它的范围是128-191，这是B类地址的范围<br>C类地址：网络号第1部分，也就是8位2进制是110打头。所以它的范围是192-223，这是C类地址的范围<br>在同一个局域网上的主机或路由器的IP地址中的网络号部分必须是一样的。  </p>
</blockquote>
<ul>
<li>几个特殊的地址</li>
</ul>
<blockquote>
<p>1、127.0.0.1 本地环回地址<br>2、169.254.0.0 windows系统自动分配地址时，DHCP服务器没给地址，计算机没办法，临时生成的地址<br>3、保留的私网地址<br>    3.1 10.0.0.0<br>    3.2 172.16.0.0 — 172.31.0.0<br>    3.3 192.168.0.0 —192.168.255.0  </p>
</blockquote>
<p><strong>2.3 IP地址和硬件地址</strong><br><img src="%E7%BD%91%E7%BB%9C%E5%B1%82/IP%E5%9C%B0%E5%9D%80%E5%92%8CMac%E5%9C%B0%E5%9D%80.png" alt><br><img src="%E7%BD%91%E7%BB%9C%E5%B1%82/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-22%20%E4%B8%8B%E5%8D%885.28.44.png" alt></p>
<blockquote>
<p>路由器<strong>只根据目的站的 IP 地址的网络号进行路由选择</strong>。  
在具体的物理网络的链路层只能看见 MAC 帧而看不见 IP 数据报<br>IP 层抽象的互联网屏蔽了下层很复杂的细节。<br>在抽象的网络层上讨论问题，就能够使用统一的、抽象的 IP 地址研究主机和主机或主机和路由器之间的通信 。  </p>
</blockquote>
<p><strong>2.4 地址解析协议 ARP</strong></p>
<ul>
<li>作用： 从网络层使用的 IP 地址，解析出在数据链路层使用的硬件地址。</li>
</ul>
<p>不管网络层使用的是什么协议，在实际网络的链路上传送数据帧时，<strong>最终还是必须使用硬件地址</strong>。 每一个主机都设有一个 ARP 高速缓存 (ARP cache)，里面有所在的局域网上的<strong>各主机和路由器的 IP 地址到硬件地址的映射表</strong></p>
<p>解析的过程：</p>
<ul>
<li>当主机 A 欲向本局域网上的某个主机 B 发送 IP 数据报时，就先在其 ARP 高速缓存中查看有无主机 B 的 IP 地址。</li>
<li>如有，就可查出其对应的硬件地址，再将此硬件地址写入 MAC 帧，然后通过局域网将该 MAC 帧发往此硬件地址。</li>
<li>如没有， ARP 进程在本局域网上广播发送一个 ARP 请求分组。收到 ARP 响应分组后，将得到的 IP 地址到硬件地址的映射写入 ARP 高速缓存。</li>
</ul>
<p>ARP 是<strong>解决同一个局域网上的主机或路由器的 IP 地址和硬件地址的映射问题</strong>。</p>
<ul>
<li>如果所要找的主机和源主机<strong>不在同一个局域网上</strong>，那么就要通过 ARP 找到一个位于本局域网上的某个路由器的硬件地址，然后把<strong>分组发送给这个路由器</strong>，让这个路由器把分组转发给下一个网络。剩下的工作就由<strong>下一个网络来做</strong>。</li>
</ul>
<p>从 IP 地址到硬件地址的<strong>解析是自动进行的</strong>，主机的用户对这种地址解析过程是不知道的</p>
<p><strong>2.5 IP数据报</strong><br><img src="%E7%BD%91%E7%BB%9C%E5%B1%82/IP%E6%95%B0%E6%8D%AE%E6%8A%A5.png" alt></p>
<ul>
<li><strong>首部的前一部分是固定长度</strong>，共 20 字节，是所有 IP 数据报必须具有的</li>
<li>版本——占 4 位，<strong>指 IP 协议的版本</strong>。目前的 IP 协议版本号为 4 (即 IPv4)</li>
<li>首部长度——占 4 位，可表示的最大数值是 15 个单位(一个单位为 4 字节)，因此 IP 的首部长度的最大值是 60 字节</li>
<li>总长度——占 16 位，<strong>指首部和数据之和的长度，单位为字节</strong>，因此数据报的最大长度为 65535 字节。总长度必须不超过最大传送单元 MTU。</li>
<li>标志(flag) ——占 3 位，<strong>目前只有前两位有意义</strong>。标志字段的最低位是 MF (More Fragment)。MF  1 表示后面“还有分片”。MF  0 表示最后一个分片。标志字段中间的一位是 DF (Don’t Fragment) 。只有当 DF  0 时才允许分片。</li>
<li>片偏移—— 占13 位，指出：<strong>较长的分组在分片后某片在原分组中的相对位置</strong>。片偏移以 8 个字节为偏移单位。</li>
<li>生存时间——占8 位，记为 TTL (Time To Live)，<strong>指示数据报在网络中可通过的路由器数的最大值</strong>。</li>
<li>协议——占8 位，<strong>指出此数据报携带的数据使用何种协议</strong>，以便目的主机的 IP 层将数据部分上交给那个处理过程</li>
<li>首部检验和——占16 位，<strong>只检验数据报的首部，不检验数据部分</strong>。这里不采用 CRC 检验码而采用简单的计算方法。</li>
<li>源地址和目的地址都各占 4 字节</li>
</ul>
<p>IP数据包是可支持多种协议的：<strong>IP 数据报可以封装多种协议 PDU。</strong><br><img src="%E7%BD%91%E7%BB%9C%E5%B1%82/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-22%20%E4%B8%8B%E5%8D%887.38.16.png" alt></p>
<p><strong>2.6 分组转发流程</strong></p>
<ul>
<li>IP 数据报的首部中<strong>没有地方可以用来指明“下一跳路由器的 IP 地址”。</strong></li>
<li>当路由器收到待转发的数据报，不是将下一跳路由器的 IP 地址填入 IP 数据报，<strong>而是送交下层的网络接口软件。</strong></li>
<li>网络接口软件使用 ARP 负责将下一跳路由器的 IP 地址转换成硬件地址，<strong>并将此硬件地址放在链路层的 MAC 帧的首部，然后根据这个硬件地址找到下一跳路由器</strong></li>
</ul>
<p>在路由表中，对每一条路由，最主要的是（目的网络地址，下一跳地址） </p>
<ul>
<li>IP 数据报最终一定可以找到目的主机所在目的网络上的路由器（可能要通过多次的间接交付）。</li>
<li><strong>只有到达最后一个路由器时，才试图向目的主机进行直接交付</strong>。</li>
</ul>
<p>分组转发算法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(1)  从数据报的首部提取目的主机的 IP 地址 D, 得出目的网络地址为 N。</span><br><span class="line">(2)  若网络 N 与此路由器直接相连，则把数据报直接交付目的主机 D；否则是间接交付，执行(3)。</span><br><span class="line">(3)  若路由表中有目的地址为 D 的特定主机路由，则把数据报传送给路由表中所指明的下一跳路由器；否则，执行(4)。</span><br><span class="line">(4)  若路由表中有到达网络 N 的路由，则把数据报传送给路由表指明的下一跳路由器；否则，执行(5)。</span><br><span class="line">(5) 若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；否则，执行(6)。</span><br><span class="line">(6)  报告转发分组出错。</span><br></pre></td></tr></table></figure>

<h2 id="3-子网掩码-与-子网划分-与-构造超网（无分类编址CIDR）"><a href="#3-子网掩码-与-子网划分-与-构造超网（无分类编址CIDR）" class="headerlink" title="3. 子网掩码 与 子网划分 与 构造超网（无分类编址CIDR）"></a>3. 子网掩码 与 子网划分 与 构造超网（无分类编址CIDR）</h2><p><strong>3.1 划分子网</strong><br>从两级IP变成三级IP</p>
<ul>
<li>划分子网纯属一个单位内部的事情。单位对外仍然表现为没有划分子网的网络。</li>
<li>从主机号借用若干个位作为子网号 subnet-id，而主机号 host-id 也就相应减少了若干个位。</li>
</ul>
<p>那么自从使用了子网划分以后，我们的<strong>分组转发就会变得简单一些：通过目的子网号能过滤出不少的主机</strong></p>
<ol>
<li>凡是从其他网络发送给本单位某个主机的 IP 数据报，仍然是根据 IP 数据报的目的网络号 net-id，先找到连接在本单位网络上的路由器。</li>
<li>然后此<strong>路由器在收到 IP 数据报后，再按目的网络号 net-id 和子网号 subnet-id 找到目的子网。</strong></li>
<li>最后就将 IP 数据报直接交付目的主机。</li>
</ol>
<p><strong>3.2 子网掩码</strong></p>
<ul>
<li>(IP 地址) AND (子网掩码) =网络地址<br><img src="%E7%BD%91%E7%BB%9C%E5%B1%82/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-22%20%E4%B8%8B%E5%8D%888.48.12.png" alt><br><img src="%E7%BD%91%E7%BB%9C%E5%B1%82/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-22%20%E4%B8%8B%E5%8D%888.48.29.png" alt></li>
</ul>
<blockquote>
<p>但在划分子网的情况下，从 IP 地址却不能唯一地得出网络地址来，这是因为网络地址取决于那个网络所采用的子网掩码，但数据报的首部并没有提供子网掩码的信息。  </p>
<p> 因此分组转发的算法也必须做相应的改动。  </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(1) 从收到的分组的首部提取目的 IP 地址 D。</span><br><span class="line">(2) 先用各网络的子网掩码和 D 逐位相“与”，看是否和</span><br><span class="line">     相应的网络地址匹配。若匹配，则将分组直接交付。</span><br><span class="line">     否则就是间接交付，执行(3)。</span><br><span class="line">(3) 若路由表中有目的地址为 D 的特定主机路由，则将</span><br><span class="line">     分组传送给指明的下一跳路由器；否则，执行(4)。</span><br><span class="line">(4) 对路由表中的每一行的子网掩码和 D 逐位相“与”，</span><br><span class="line">     若其结果与该行的目的网络地址匹配，则将分组传送</span><br><span class="line">     给该行指明的下一跳路由器；否则，执行(5)。</span><br><span class="line">(5) 若路由表中有一个默认路由，则将分组传送给路由表</span><br><span class="line">     中所指明的默认路由器；否则，执行(6)。</span><br><span class="line">(6) 报告转发分组出错。</span><br></pre></td></tr></table></figure>

<p><img src="%E7%BD%91%E7%BB%9C%E5%B1%82/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-22%20%E4%B8%8B%E5%8D%888.52.24.png" alt></p>
<p><img src="%E7%BD%91%E7%BB%9C%E5%B1%82/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-22%20%E4%B8%8B%E5%8D%889.04.03.png" alt><br><img src="%E7%BD%91%E7%BB%9C%E5%B1%82/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-22%20%E4%B8%8B%E5%8D%889.06.17.png" alt><br><img src="%E7%BD%91%E7%BB%9C%E5%B1%82/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-22%20%E4%B8%8B%E5%8D%889.06.32.png" alt><br><img src="%E7%BD%91%E7%BB%9C%E5%B1%82/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-22%20%E4%B8%8B%E5%8D%889.06.44.png" alt></p>
<p><strong>3.3 无分类编址CIDR</strong></p>
<p>提出的背景:</p>
<blockquote>
<p>划分子网在一定程度上缓解了互联网在发展中遇到的困难。然而在 1992 年互联网仍然面临三个必须尽早解决的问题：<br> (1) B 类地址在 1992 年已分配了近一半，眼看就要在 1994 年 3 月全部分配完毕！<br>(2) 互联网主干网上的路由表中的项目数急剧增长（从几千个增长到几万个）。<br>(3) 整个 IPv4 的地址空间最终将全部耗尽  </p>
</blockquote>
<p>CIDR干了什么：</p>
<ul>
<li>CIDR消除了传统的 A 类、B 类和 C 类地址以及划分子网的概念，因而可以更加有效地分配 IPv4 的地址空间。</li>
<li>CIDR使用各种长度的“网络前缀”(network-prefix)来代替分类地址中的网络号和子网号。</li>
<li>IP 地址从三级编址（使用子网掩码）又回到了两级编址。 </li>
</ul>
<p>CIDR 使用“斜线记法”(slash notation)，它又称为 CIDR 记法，<strong>即在 IP 地址面加上一个斜线“/”，然后写上网络前缀所占的位数（这个数值对应于三级编址中子网掩码中 1 的个数）</strong>。例如： 220.78.168.0/24</p>
<p>无分类的两级编址的记法是：<br><img src="%E7%BD%91%E7%BB%9C%E5%B1%82/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-22%20%E4%B8%8B%E5%8D%8811.15.59.png" alt></p>
<ul>
<li>CIDR 还使用“斜线记法”(slash notation)，它又称为CIDR记法，即在 IP 地址面加上一个斜线“/”，然后写上网络前缀所占的位数（这个数值对应于三级编址中子网掩码中 1 的个数）。</li>
<li>CIDR 把网络前缀都相同的连续的 IP 地址组成“CIDR 地址块”。</li>
</ul>
<h2 id="4-网际控制报文协议-ICMP"><a href="#4-网际控制报文协议-ICMP" class="headerlink" title="4. 网际控制报文协议 ICMP"></a>4. 网际控制报文协议 ICMP</h2><ul>
<li>ICMP 报文作为 IP 层数据报的数据，加上数据报的首部，组成 IP 数据报发送出去</li>
<li>ICMP 允许主机或路由器报告差错情况和提供有关异常情况的报告</li>
</ul>
<p>4.1 ICMP 报文的种类</p>
<ul>
<li>ICMP 报文的种类有两种，即 ICMP 差错报告报文和 ICMP 询问报文。 </li>
<li>ICMP 报文的前 4 个字节是统一的格式，共有三个字段：即类型、代码和检验和。接着的 4 个字节的内容与 ICMP 的类型有关</li>
</ul>
<ul>
<li><input disabled type="checkbox"> 差错报告报文</li>
</ul>
<ol>
<li>终点不可达 </li>
<li>源点抑制(Source quench)  </li>
<li>时间超过 </li>
<li>参数问题 </li>
<li>改变路由（重定向）(Redirect)<br><img src="%E7%BD%91%E7%BB%9C%E5%B1%82/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-06-07%2011.12.17.png" alt></li>
</ol>
<ul>
<li><input disabled type="checkbox"> 询问报文</li>
</ul>
<ol>
<li>回送请求和回答</li>
<li>时间戳请求和回答</li>
</ol>
<p>4.2 ICMP应用举例<br><strong>PING分组网间探测</strong>，用来测试两个主机之间的连通性，使用了回送请求和回送回答报文。应用层直接使用网络层，没有通过运输层的TCP或UDP</p>
<h2 id="5-因特网的路由选择协议"><a href="#5-因特网的路由选择协议" class="headerlink" title="5. 因特网的路由选择协议"></a>5. 因特网的路由选择协议</h2><ul>
<li>静态路由选择策略——即非自适应路由选择，其特点是简单和开销较小，但不能及时适应网络状态的变化。 </li>
<li>动态路由选择策略——即自适应路由选择，其特点是能较好地适应网络状态的变化，但实现起来较为复杂，开销也比较大。</li>
</ul>
<p>自治系统AS</p>
<p>因特网有两大类路由选择协议</p>
<ul>
<li><input disabled type="checkbox"> 内部网关协议 <strong>IGP</strong> (Interior Gateway Protocol)    即在一个自治系统内部使用的路由选择协议。目前这类路由选择协议使用得最多，如 <strong>RIP</strong> 和 <strong>OSPF</strong> 协议。</li>
<li><input disabled type="checkbox"> 外部网关协议<strong>EGP</strong> (External Gateway Protocol)    若源站和目的站处在不同的自治系统中，当数据报传到一个自治系统的边界时，就需要使用一种协议将路由选择信息传递到另一个自治系统中。这样的协议就是外部网关协议 EGP。在外部网关协议中目前使用最多的是 <strong>BGP-4</strong></li>
</ul>
<p>自治系统之间的路由选择也叫做域间路由选择<br>在自治系统内部的路由选择叫做域内路由选择</p>
<p><strong>5.2 内部网关协议 RIP</strong><br>RIP 是一种分布式的基于距离向量的路由选择协议<br>RIP 协议要求网络中的每一个路由器都要维护从它自己到其他每一个目的网络的距离记录</p>
<p>三个要点：</p>
<ul>
<li>仅和相邻路由器交换信息。 </li>
<li>交换的信息是当前本路由器所知道的全部信息，即自己的路由表。 </li>
<li>按固定的时间间隔交换路由信息，例如，每隔 30 秒</li>
</ul>
<p>距离向量算法：<br><img src="%E7%BD%91%E7%BB%9C%E5%B1%82/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-06-07%2016.18.17.png" alt></p>
<p>主要缺点：好消息传播得快，而坏消息传播得慢，网络出故障的传播时间往往需要较长的时间(例如数分钟)</p>
<p><strong>5.3 内部网关协议 OSPF</strong><br>是分布式的链路状态协议</p>
<p>三个要点：</p>
<ul>
<li>向本自治系统中所有路由器发送信息，这里使用的方法是洪泛法。</li>
<li>发送的信息就是与本路由器相邻的所有路由器的链路状态，但这只是路由器所知道的部分信息。<ul>
<li>“链路状态”就是说明本路由器都和哪些路由器相邻，以及该链路的“度量”(metric)。 </li>
</ul>
</li>
<li>只有当链路状态发生变化时，路由器才用洪泛法向所有路由器发送此信息。</li>
</ul>
<p>链路状态数据库：</p>
<ul>
<li>由于各路由器之间频繁地交换链路状态信息，因此所有的路由器最终都能建立一个链路状态数据库。</li>
<li>这个数据库实际上就是全网的拓扑结构图，它在全网范围内是一致的（这称为链路状态数据库的同步）。</li>
<li>OSPF 的链路状态数据库能较快地进行更新，使各个路由器能及时更新其路由表。OSPF 的更新过程收敛得快是其重要优点</li>
</ul>
<p><strong>5.4 外部网关协议 BGP</strong></p>
<p>不同自治系统的路由器之间交换路由信息的协议</p>
<p>#课内</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">John Doe</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
